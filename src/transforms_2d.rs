use std::f64;
use itertools::Itertools;

use haar_1d;
use dct_1d;

pub enum TransformType {
    DctForward,
    DctInverse,
    HaarForward,
    HaarInverse
}

pub struct Transform {
    pub input: Vec<f64>,
    pub transform_type: fn(input: &Vec<f64>) -> Vec<f64>
}

impl Transform {
    pub fn new(input: Vec<f64>, transform_type: TransformType) -> Transform {
        let transform_type = match transform_type {
            TransformType::DctForward => dct_1d::forward,
            TransformType::DctInverse => dct_1d::inverse,
            TransformType::HaarForward => haar_1d::forward,
            TransformType::HaarInverse => haar_1d::inverse
        };

        Transform {
            input,
            transform_type
        }
    }

    pub fn transform(&self) -> Vec<f64> {
        let mut output: Vec<f64> = Vec::new();
        let mut output_temp: Vec<f64> = Vec::new();
        let mut forward_input = Vec::new();

        for chunks in &self.input.iter().chunks(8) {
            forward_input = (self.transform_type)(&chunks.map(|x| *x).collect_vec());

            output.extend(forward_input.iter().cloned());
        }

        forward_input.clear();

        for x in 0..8 {
            for y in 0..8 {
                forward_input.push(output[x + 8 * y]);
            }

            output_temp.extend((self.transform_type)(&forward_input).iter().cloned());

            forward_input.clear();
        }

        for x in 0..8 {
            for y in 0..8 {
                output[x + 8 * y] = output_temp[x * 8 + y];
            }
        }

        output
    }
}

#[test]
fn dct_2d_forward_test() {
    let input = vec![139.0, 144.0, 149.0, 153.0, 155.0, 155.0, 155.0, 155.0,
                     144.0, 151.0, 153.0, 156.0, 159.0, 156.0, 156.0, 156.0,
                     150.0, 155.0, 160.0, 163.0, 158.0, 156.0, 156.0, 156.0,
                     159.0, 161.0, 162.0, 160.0, 160.0, 159.0, 159.0, 159.0,
                     159.0, 160.0, 161.0, 162.0, 162.0, 155.0, 155.0, 155.0,
                     161.0, 161.0, 161.0, 161.0, 160.0, 157.0, 157.0, 157.0,
                     162.0, 162.0, 161.0, 163.0, 162.0, 157.0, 157.0, 157.0,
                     162.0, 162.0, 161.0, 161.0, 163.0, 158.0, 158.0, 158.0];

    let expected = vec![1259.6249999999998, -1.0333282734264215, -12.08089972227818, -5.202897632351193, 2.1250000000000395, -1.6724303924125188, -2.7079719164466214, 1.3238449641647345,
                        -22.59043604867432, -17.484184984963697, -6.240475613706441, -3.157375133336737, -2.85566531990981, -0.06945585634862816, 0.4341651476704207, -1.1855839794560317,
                        -10.949263949383607, -9.262395706197365, -1.5758252147247727, 1.5300904757770628, 0.20294853755482178, -0.9418636259697495, -0.5669417382415787, -0.0629237344895699,
                        -7.08155510708346, -1.907176033199822, 0.22478966756064506, 1.4538889620374085, 0.8962513174481048, -0.07987423319341946, -0.04229084057506394, 0.33153831902135955,
                        -0.6249999999999432, -0.838108358920093, 1.4698833354859264, 1.556281617916448, -0.12499999999999822, -0.66098605785626, 0.6088456126644615, 1.275209526220424,
                        1.7540818213960137, -0.20285866258103136, 1.620486613351027, -0.34243736611696535, -0.7755381437234861, 1.4759360604641896, 1.0410044136725525, -0.9929624708267335,
                        -1.2825244507344138, -0.3599527941914801, -0.31694173824158023, -1.4600985413244758, -0.4899611118286471, 1.734842538986418, 1.0758252147247698, -0.7613475106449024,
                        -2.5998987210929343, 1.551852887620423, -3.762776290221531, -1.8447577060244742, 1.8716168796703228, 1.213945210222894, -0.567884993512257, -0.44564003753785386];

    let dct_forward = Transform::new(input, TransformType::DctForward).transform();

    assert_eq!(dct_forward, expected);
}

#[test]
fn dct_2d_inverse_test() {
    let input = vec![1259.6249999999998, -1.0333282734264215, -12.08089972227818, -5.202897632351193, 2.1250000000000395, -1.6724303924125188, -2.7079719164466214, 1.3238449641647345,
                     -22.59043604867432, -17.484184984963697, -6.240475613706441, -3.157375133336737, -2.85566531990981, -0.06945585634862816, 0.4341651476704207, -1.1855839794560317,
                     -10.949263949383607, -9.262395706197365, -1.5758252147247727, 1.5300904757770628, 0.20294853755482178, -0.9418636259697495, -0.5669417382415787, -0.0629237344895699,
                     -7.08155510708346, -1.907176033199822, 0.22478966756064506, 1.4538889620374085, 0.8962513174481048, -0.07987423319341946, -0.04229084057506394, 0.33153831902135955,
                     -0.6249999999999432, -0.838108358920093, 1.4698833354859264, 1.556281617916448, -0.12499999999999822, -0.66098605785626, 0.6088456126644615, 1.275209526220424,
                     1.7540818213960137, -0.20285866258103136, 1.620486613351027, -0.34243736611696535, -0.7755381437234861, 1.4759360604641896, 1.0410044136725525, -0.9929624708267335,
                     -1.2825244507344138, -0.3599527941914801, -0.31694173824158023, -1.4600985413244758, -0.4899611118286471, 1.734842538986418, 1.0758252147247698, -0.7613475106449024,
                     -2.5998987210929343, 1.551852887620423, -3.762776290221531, -1.8447577060244742, 1.8716168796703228, 1.213945210222894, -0.567884993512257, -0.44564003753785386];

    let expected = vec![139.0, 144.0, 149.0, 153.0, 155.0, 155.0, 155.0, 155.0,
                        144.0, 151.0, 153.0, 156.0, 159.0, 156.0, 156.0, 156.0,
                        150.0, 155.0, 160.0, 163.0, 158.0, 156.0, 156.0, 156.0,
                        159.0, 161.0, 162.0, 160.0, 160.0, 159.0, 159.0, 159.0,
                        159.0, 160.0, 161.0, 162.0, 162.0, 155.0, 155.0, 155.0,
                        161.0, 161.0, 161.0, 161.0, 160.0, 157.0, 157.0, 157.0,
                        162.0, 162.0, 161.0, 163.0, 162.0, 157.0, 157.0, 157.0,
                        162.0, 162.0, 161.0, 161.0, 163.0, 158.0, 158.0, 158.0];

    let mut dct_inverse = Transform::new(input, TransformType::DctInverse).transform();

    for x in 0..8 {
        for y in 0..8 {
            dct_inverse[x * 8 + y] = dct_inverse[x * 8 + y].round();
        }
    }

    assert_eq!(dct_inverse, expected)
}

#[test]
fn haar_2d_forward_test() {
    let input = vec![139.0, 144.0, 149.0, 153.0, 155.0, 155.0, 155.0, 155.0,
                     144.0, 151.0, 153.0, 156.0, 159.0, 156.0, 156.0, 156.0,
                     150.0, 155.0, 160.0, 163.0, 158.0, 156.0, 156.0, 156.0,
                     159.0, 161.0, 162.0, 160.0, 160.0, 159.0, 159.0, 159.0,
                     159.0, 160.0, 161.0, 162.0, 162.0, 155.0, 155.0, 155.0,
                     161.0, 161.0, 161.0, 161.0, 160.0, 157.0, 157.0, 157.0,
                     162.0, 162.0, 161.0, 163.0, 162.0, 157.0, 157.0, 157.0,
                     162.0, 162.0, 161.0, 161.0, 163.0, 158.0, 158.0, 158.0];

    let expected = vec![157.453125,  0.015625, -1.71875,  0.8125, -1.25,  -0.6875,  1.625, 0.0,
                        -2.171875, -1.609375, -1.59375, -0.4375, -1.125, -0.3125, -0.875, 0.0,
                        -3.03125,  -2.03125,  -0.8125,   0.0,    -0.625, -0.75,    0.0,   0.0,
                        -0.625,     0.125,    -0.375,    0.0,    -0.125,  0.125,   0.0,   0.0,
                        -1.625,    -0.75,     -0.625,   -0.375,   0.5,   -0.25,   -0.75,  0.0,
                        -1.5625,   -0.1875,   -2.0,      0.125,  -0.75,  -1.25,    0.25,  0.0,
                        -0.375,     0.125,    -0.5,      0.5,    -0.25,  -0.25,    1.0,   0.0,
                        -0.125,     0.375,    -0.25,     0.0,     0.0,   -0.5,     0.0,   0.0];

    let haar_forward = Transform::new(input, TransformType::HaarForward).transform();

    assert_eq!(haar_forward, expected);
}

#[test]
fn haar_2d_inverse_test() {
    let input = vec![157.453125,  0.015625, -1.71875,  0.8125, -1.25,  -0.6875,  1.625, 0.0,
                     -2.171875, -1.609375, -1.59375, -0.4375, -1.125, -0.3125, -0.875, 0.0,
                     -3.03125,  -2.03125,  -0.8125,   0.0,    -0.625, -0.75,    0.0,   0.0,
                     -0.625,     0.125,    -0.375,    0.0,    -0.125,  0.125,   0.0,   0.0,
                     -1.625,    -0.75,     -0.625,   -0.375,   0.5,   -0.25,   -0.75,  0.0,
                     -1.5625,   -0.1875,   -2.0,      0.125,  -0.75,  -1.25,    0.25,  0.0,
                     -0.375,     0.125,    -0.5,      0.5,    -0.25,  -0.25,    1.0,   0.0,
                     -0.125,     0.375,    -0.25,     0.0,     0.0,   -0.5,     0.0,   0.0];

    let expected = vec![139.0, 144.0, 149.0, 153.0, 155.0, 155.0, 155.0, 155.0,
                        144.0, 151.0, 153.0, 156.0, 159.0, 156.0, 156.0, 156.0,
                        150.0, 155.0, 160.0, 163.0, 158.0, 156.0, 156.0, 156.0,
                        159.0, 161.0, 162.0, 160.0, 160.0, 159.0, 159.0, 159.0,
                        159.0, 160.0, 161.0, 162.0, 162.0, 155.0, 155.0, 155.0,
                        161.0, 161.0, 161.0, 161.0, 160.0, 157.0, 157.0, 157.0,
                        162.0, 162.0, 161.0, 163.0, 162.0, 157.0, 157.0, 157.0,
                        162.0, 162.0, 161.0, 161.0, 163.0, 158.0, 158.0, 158.0];

    let haar_inverse = Transform::new(input, TransformType::HaarInverse).transform();

    assert_eq!(haar_inverse, expected);
}