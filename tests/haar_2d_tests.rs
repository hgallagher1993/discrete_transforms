extern crate discrete_transforms;

use discrete_transforms::transforms_2d::*;

#[test]
fn haar_2d_forward_test() {
    let input = vec![139.0, 144.0, 149.0, 153.0, 155.0, 155.0, 155.0, 155.0,
                     144.0, 151.0, 153.0, 156.0, 159.0, 156.0, 156.0, 156.0,
                     150.0, 155.0, 160.0, 163.0, 158.0, 156.0, 156.0, 156.0,
                     159.0, 161.0, 162.0, 160.0, 160.0, 159.0, 159.0, 159.0,
                     159.0, 160.0, 161.0, 162.0, 162.0, 155.0, 155.0, 155.0,
                     161.0, 161.0, 161.0, 161.0, 160.0, 157.0, 157.0, 157.0,
                     162.0, 162.0, 161.0, 163.0, 162.0, 157.0, 157.0, 157.0,
                     162.0, 162.0, 161.0, 161.0, 163.0, 158.0, 158.0, 158.0];

    let expected = vec![157.453125,  0.015625, -1.71875,  0.8125, -1.25,  -0.6875,  1.625, 0.0,
                        -2.171875, -1.609375, -1.59375, -0.4375, -1.125, -0.3125, -0.875, 0.0,
                        -3.03125,  -2.03125,  -0.8125,   0.0,    -0.625, -0.75,    0.0,   0.0,
                        -0.625,     0.125,    -0.375,    0.0,    -0.125,  0.125,   0.0,   0.0,
                        -1.625,    -0.75,     -0.625,   -0.375,   0.5,   -0.25,   -0.75,  0.0,
                        -1.5625,   -0.1875,   -2.0,      0.125,  -0.75,  -1.25,    0.25,  0.0,
                        -0.375,     0.125,    -0.5,      0.5,    -0.25,  -0.25,    1.0,   0.0,
                        -0.125,     0.375,    -0.25,     0.0,     0.0,   -0.5,     0.0,   0.0];

    let haar_forward = Transform::new(input, TransformType::HaarForward).transform();

    assert_eq!(haar_forward, expected);
}

#[test]
fn haar_2d_inverse_test() {
    let input = vec![157.453125,  0.015625, -1.71875,  0.8125, -1.25,  -0.6875,  1.625, 0.0,
                     -2.171875, -1.609375, -1.59375, -0.4375, -1.125, -0.3125, -0.875, 0.0,
                     -3.03125,  -2.03125,  -0.8125,   0.0,    -0.625, -0.75,    0.0,   0.0,
                     -0.625,     0.125,    -0.375,    0.0,    -0.125,  0.125,   0.0,   0.0,
                     -1.625,    -0.75,     -0.625,   -0.375,   0.5,   -0.25,   -0.75,  0.0,
                     -1.5625,   -0.1875,   -2.0,      0.125,  -0.75,  -1.25,    0.25,  0.0,
                     -0.375,     0.125,    -0.5,      0.5,    -0.25,  -0.25,    1.0,   0.0,
                     -0.125,     0.375,    -0.25,     0.0,     0.0,   -0.5,     0.0,   0.0];

    let expected = vec![139.0, 144.0, 149.0, 153.0, 155.0, 155.0, 155.0, 155.0,
                        144.0, 151.0, 153.0, 156.0, 159.0, 156.0, 156.0, 156.0,
                        150.0, 155.0, 160.0, 163.0, 158.0, 156.0, 156.0, 156.0,
                        159.0, 161.0, 162.0, 160.0, 160.0, 159.0, 159.0, 159.0,
                        159.0, 160.0, 161.0, 162.0, 162.0, 155.0, 155.0, 155.0,
                        161.0, 161.0, 161.0, 161.0, 160.0, 157.0, 157.0, 157.0,
                        162.0, 162.0, 161.0, 163.0, 162.0, 157.0, 157.0, 157.0,
                        162.0, 162.0, 161.0, 161.0, 163.0, 158.0, 158.0, 158.0];

    let haar_inverse = Transform::new(input, TransformType::HaarInverse).transform();

    assert_eq!(haar_inverse, expected);
}